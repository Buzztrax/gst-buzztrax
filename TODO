= tempo =
a) should we rename 'tempo' to 'tempo_sync' or 'song_tempo'?
b) can we remove the iface and use TAGS?
  - we already have GST_TAG_BEATS_PER_MINUTE
    gst_tag_register (GST_TAG_BEATS_PER_MINUTE, GST_TAG_FLAG_META, G_TYPE_DOUBLE,
      _("beats per minute"), _("number of beats per minute in audio"), NULL);
  - we need GST_TAG_TICKS_PER_BEAT and GST_TAG_SUBTICKS_PER_TICK
    where to register them?
  - the main problem with tags instead of an iface is that it is not easy to
    change it while playing, we'd need to use the playback rate
c) can we use events?
   - the application would push them on to the sink and they travel up to the
     sources

= GstBtChildBin =
- would be useful for the GstIirEqualizerNBands (num-bands->children)


= GstSimsyn =
- have more variants in the same plugin (share code, like oszillators and filter)
  - we'd like to have one with
    - dual-osc
    - two ADSR envelopes
    - each envelope can modulate volume and filter-cutoff/resonance
  - current simsyn is missing key-tracking for the filter
    - we could add a boolean to enable key-tracking (false by default)
    - on cut-off changes we need to base it on the currently played note
    - current cut-off range is 0.0->1.0 with 1.0 = srat/2.0
    - v1: we could map 1.0 -> note_freq*32.0 (5 harmonics) instead
    - v2: we could assume the current cut-off is related to C-4 and rebase
      accordingly

= FrozenTrackPlayer (MemoryAudioSource) =
- when playing pre-recorded tracks, one would trigger them at the start with the
  root note
- one problem here is that we can't start playback in the middle of the song or
  loop parts
- we want a special machine that only has a wave-table parameter and plays the
  sample.
  - we should re-work memory audio source for it
  - it can be a local machine (not installed as a separate plugin), but we'd
    need to move it into bt-core (so that it works outside of the ui too)
  - machine.c currently checks for "host-callbacks" property and uses that to
    pass the BuzzCallbacks. The element can use them to access the wavetable.

= synth components =
The libgstbuzztard already has a couple of components; we'd like to extend this
to make it dead easy writing new synths.

== components ideas ==
envelope-adsr
osc-wave (wavetable oscillator)

== design ==
After adding more components we needs to extract common interfaces. Each
component would have a couple of properties and vmethods (start, process, stop).
When using them the element would proxy a few properties and ev. configure
others manually. We can use GBinding (since glib-2.26) for the proxy properties.

== open questions ==
Do we need to pass the data fmt? What about mono/stereo.

= debugging =
G_SLICE=always-malloc G_DEBUG=gc-friendly GLIBCPP_FORCE_NEW=1 GLIBCXX_FORCE_NEW=1 valgrind --tool=memcheck --leak-check=full --leak-resolution=high --trace-children=yes --num-callers=20 --suppressions=$HOME/projects/gstreamer/gstreamer/common/gst.supp gst-launch -q >/dev/null audiotestsrc num-buffers=10 ! bml-EQ-10 ! fakesink

